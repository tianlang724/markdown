# 什么是makefile
makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。
# 编译和链接
c和c++首先要把源文件编译成中间目标文件object file，windows下面是.obj文件,linux下面是.o文件,
这个过程叫做编译（compile），然后把所有的object file组合为可执行文件，这个过程叫链接（link）
## 编译 
编译是语法的正确，函数和变量的声明正确。对于声明，只需要告诉编译器头文件的位置，
只要所有的语法正确就可以编译出中间目标文件，一般每一个c/c++文件都对应一个中间目标文件。
## 链接
链接主要是链接全局变量和函数。我们可以使用中间目标文件链接目标文件。链接器不管
源文件，只管中间目标函数。一般情况由于中间目标文件太多，我们把中间目标函数打包，
在window中是库文件Libary File(.lib文件).

总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。
在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，
编译器会给出一个警告，但可以生成Object File。而在链接程序时，
链接器会在所有的Object File中找寻函数的实现，如果找不到，
那到就会报链接错误码（Linker Error），
# Makefile介绍
make命令执行的时候需要指定一个makefile文件,告诉make怎样去编译和执行。
make的规则是
1. 如果这个工程么没有被编译过，所有的源文件都要被编译和链接。
2. 如果有几个c源文件被修改过，那么只编译被修改的源文件，并链接目标程序
3. 如果有几个头文件被修改过，我们需要编译引用这几个头文件的c文件，并链接目标程序
这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编
译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不
到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不
成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，
冒号后面的文件还是不在，那么对不起，我就不工作啦。

## make是如何工作的
1. 读入主Makefile (主Makefile中可以引用其他Makefile)
2. 读入被include的其他Makefile
3. 初始化文件中的变量
4. 推导隐晦规则, 并分析所有规则
5. 为所有的目标文件创建依赖关系链
6. 根据依赖关系, 决定哪些目标要重新生成,生成规则本节开头所示
7. 执行生成命令
1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，
make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依
赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。

通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，
那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，
以此来清除所有的目标文件，以便重编译。
## makefile主要的东西
1. 显示规则：如何生成一个或多个目标文件，这是书写者指出，
2. 隐式规则：make自动推导的功能。
3. 变量的定义：变量一般都是字符串，类似c语言的宏，makefile被执行的的时候会被
扩展到引用位置
4. 文件指示:包括三个部分，一是在一个makefile中引用另一个makefile,类似c语言
的include；二是根据某些特定的情况指定makefile中有效的部分，
像c语言的预编译器#if，还有一个是定义多行命令
5. 注释：注释用“#”表示
# makefile显式规则
## makefile的规则
```
          target... : prerequisites ...
          command
```
target也就是一个目标文件，可以是Object File，也可以是执行文件。
还可以是一个标签（Label），对于标签这种特性，
在后续的“伪目标”章节中会有叙述.

prerequisites就是，要生成那个target所需要的文件或是目标。

command也就是make需要执行的命令。（任意的Shell命令）。

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于
prerequisites中的文件，其生成规则定义在command中。说白一点就是说，
prerequisites中如果有一个以上的文件比target文件要新的话，
command所定义的命令就会被执行。这就是Makefile的规则。
也就是Makefile中最核心的内容。

在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，
一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，
他只管执行所定义的命令。make会比较targets文件和prerequisites文件
的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，
或者target不存在的话，那么，make就会执行后续定义的命令。

## makefile多目标
Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，
并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，
这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），
这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。
   bigoutput littleoutput : text.g
           generate text.g -$(subst output,,$@) > $@
   上述规则等价于：
 
   bigoutput : text.g
           generate text.g -big > bigoutput
   littleoutput : text.g
           generate text.g -little > littleoutput
其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，
后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，
就像一个数组，“$@”依次取出目标，并执于命令。
## makefile静态模式多目标
静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：
```
<targets...>: <target-pattern>: <prereq-patterns ...>
　　　<commands>
```
targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。
target-parrtern是指明了targets的模式，也就是的目标集模式。
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。
这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。
如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，
而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行
二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），
并为其加上[.c]这个结尾，形成的新集合。
所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”
那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。
看一个例子：
```
   objects = foo.o bar.o
 
   all: $(objects)
 
   $(objects): %.o: %.c
           $(CC) -c $(CFLAGS) $< -o $@
``` 
上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$<”和“$@”则是自动化变量，“$<”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：
```
   foo.o : foo.c
           $(CC) -c $(CFLAGS) foo.c -o foo.o
   bar.o : bar.c
           $(CC) -c $(CFLAGS) bar.c -o bar.o
```

## 伪目标
伪目标并不是一个"目标(target)", 不像真正的目标那样会生成一个目标文件。
典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标。 
清空目标文件的规则

 每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，
 也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：
 ```
       clean:
           rm edit $(objects)
```
更为稳健的做法是：
```
       .PHONY : clean //.PHONY意思表示clean是一个“伪目标”
       clean :
               -rm edit $(objects)
```

而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，
继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成
make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放
在文件的最后”。
# 隐式规则 
如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，
make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，
那么这个行为就是隐含规则的自动推导
如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。
还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，
所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管
当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。
当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“
后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统
定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, 
.c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .
h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。
## c/c++ 用到的隐式规则的顺序
1. 编译C程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是
```
$(CC) –c $(CPPFLAGS) $(CFLAGS)
```
2. 编译C++程序的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.c”，并且其生成命令是
```
$(CXX) –c $(CPPFLAGS) $(CFLAGS)
```
（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）

...中间的暂时用不到就没有列出来

7. 汇编和汇编预处理的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”
，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。

8. 链接Object文件的隐含规则。
“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对
于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。
## 隐式规则中的变量

在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改
变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎
么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的
“-R”或“--no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。
我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数
相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量
### 关于命令的变量
AR      函数库打包程序。默认命令是“ar”。
AS      汇编语言编译程序。默认命令是“as”。
CC      C语言编译程序。默认命令是“cc”。
CXX     C++语言编译程序。默认命令是“g++”。
CPP     C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。
CTANGLE 转换C Web 到 C。默认命令是“ctangle”。
RM      删除文件命令。默认命令是“rm –f”。
### 关于命令参数的变量
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是
空。

ARFLAGS     函数库打包程序AR命令的参数。默认值是“rv”。
ASFLAGS     汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。
CFLAGS      C语言编译器参数。
CXXFLAGS    C++语言编译器参数。
CPPFLAGS    C预处理器参数。（ C 和 Fortran 编译器也会用到）。

## 定义模式规则
你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，
只是在规则中，目标的定义需要有"%"字符。"%"的意思是表示一个
或多个任意字符。在依赖目标中同样可以使用"%"，只是依赖目标中
的"%"的取值，取决于其目标。
有一点需要注意的是，"%"的展开发生在变量和函数的展开之后，变
量和函数的展开发生在make载入Makefile时，而模式规则中的"%"
发生在运行时。
模式规则中，至少在规则的目标定义中要包含"%"，否则，就是一般的规则。目标中的"%"定义
表示对文件名的匹配，"%"表示长度任意的非空字符串。例如："%.c"表示以".c"结尾的文件名
（文件名的长度至少为3），而"s.%.c"则表示以"s."开头，".c"结尾的文件名（
文件名的长度至少为 5）。

如果"%"定义在目标中，那么，目标中的"%"的值决定了依赖目标中的"%"的值，也就是说，
目标中的模式的"%"决定了依赖目标中"%"的样子。例如有一个模式规则如下：

%.o : %.c ; <command ......>
下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.

```
%.o : %.c
$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```
其中，"$@"表示所有的目标的挨个值，"$<"表示了所有依赖目标的挨个值
## 自动变量
所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，
直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。

下面是所有的自动化变量及其说明：

1. $@
表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，
"$@"就是匹配于目标中模式定义的集合。
2. $%
仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a(bar.o)"，
那么，"$%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件（Unix下是
[.a]，Windows下是[.lib]），那么，其值为空。
3. $<
依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$<"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
4. $?
所有比目标新的依赖目标的集合。以空格分隔。
5. $^
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。
6. $+
这个变量很像"$^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
7. $*
这个变量表示目标模式中"%"及其之前的部分。如果目标是"dir/a.foo.b"，并且目标的模式是"a.%.b"，那么，"$*"的值就是"dir /a.foo"。这个变量对于构造有关联的文件名是比
# make 变量
在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，
在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，
你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”
或是 Makefile的其它部分中。
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”
或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。
变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。。
## 变量命名规范
。变量的命名字可以包含字符、数字，下划线（可以是数字开头），
但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的。
## 变量的定义 
```
objects_add1 =$(objects) b
objects=a

```
或者 
```
objects_add2 :=$(objects) b
objects:=a
```
其中 = 和 := 的区别在于, := 只能使用前面定义好的变量, = 可以使用后面定义的变量
objects_add1=a b,objects_add2=b.
## 变量替换
我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，
其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是
“空格”或是“结束符”。
```
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```
这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”
字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。

另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：
```
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
```
这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，
这个例子同样让$(bar)变量的值为“a.c b.c c.c”。

## 变量嵌套
“把变量的值再当成变量”。先看一个例子：
```
x = y
y = z
a := $($(x))
```
在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。
（注意，是“x=y”，而不是“x=$(y)”）
## 变量追加
我们可以使用“+=”操作符给变量追加值，如：
```
objects = main.o foo.o bar.o utils.o
objects += another.o
```
等价于：
```
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
```
## 变量覆盖override 
作用是使 Makefile中定义的变量能够覆盖 make 命令参数中指定的变量

语法:
```
override <variable> = <value>
override <variable> := <value>
override <variable> += <value>
```
# 文件指示 
## makefile文件搜索
默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件。
“GNUmakefile”，这个文件是GNU的make识别的。
指定特定的Makefile，你可以使用make的“-f”和“--file”参数，如：
```
make -f Make.Linux
make --file Make.AIX
```
## makefile路径搜索
当一个Makefile中涉及到大量源文件时(这些源文件和Makefile极有可能不在同一个目录中),
这时, 最好将源文件的路径明确在Makefile中, 便于编译时查找. Makefile中有个特殊的变量 
VPATH 就是完成这个功能的.指定了 VPATH 之后, 如果当前目录中没有找到相应文件或依赖的文件, 
Makefile 回到 VPATH 指定的路径中再去查找..

VPATH 使用方法:

vpath <directories>            :: 当前目录中找不到文件时, 就从<directories>中搜索
vpath <pattern> <directories>  :: 符合<pattern>格式的文件, 就从<directories>中搜索
vpath <pattern>                :: 清除符合<pattern>格式的文件搜索路径
vpath                          :: 清除所有已经设置好的文件路径

当前目录中找不到文件时, 按顺序从 src目录 ../parent-dir目录中查找文件
```
VPATH src:../parent-dir   
```
.h结尾的文件都从 ./header 目录中查找
```
VPATH %.h ./header
```
清除示例2中设置的规则
```
VPATH %.h
```
清除所有VPATH的设置
```
VPATH
```

## 在makefile中引用其他makefile

在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，
被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
```
include<filename>
```
filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符在include前面可以有一些空字符，
但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。
举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，
其包含了e.mk和f.mk，那么，下面的语句：
```
   include foo.make *.mk $(bar)
等价于：
   include foo.make a.mk b.mk c.mk e.mk f.mk
```
make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++
的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当
目录下没有找到，那么，make还会在下面的几个目录下找：
1. 如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。
2. 如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。
如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
-include<filename>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。
# 其它项
## 特殊符号
1. 反斜杠（\）是换行符的意思。

*     :: 表示任意一个或多个字符
?     :: 表示任意一个字符
[...] :: ex. [abcd] 表示a,b,c,d中任意一个字符, [^abcd]表示除a,b,c,d以外的字符, [0-9]表示 0~9中任意一个数字
~     :: 表示用户的home目录
## make 退出码
Makefile的退出码有以下3种：
0 :: 表示成功执行
1 :: 表示make命令出现了错误
2 :: 使用了 "-q" 选项, 并且make使得一些目标不需要更新
## make 参数介绍

make 的参数有很多, 可以通过 make -h 去查看
--debug[=<options>]	输出make的调试信息, options 可以是 a, b, v
-j --jobs	同时运行的命令的个数, 也就是多线程执行 Makefile
-r --no-builtin-rules	禁止使用任何隐含规则
-R --no-builtin-variabes	禁止使用任何作用于变量上的隐含规则
-B --always-make	假设所有目标都有更新, 即强制重编译
