# 什么是makefile
makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。
# 编译和链接
c和c++首先要把源文件编译成中间目标文件object file，windows下面是.obj文件,linux下面是.o文件,
这个过程叫做编译（compile），然后把所有的object file组合为可执行文件，这个过程叫链接（link）
## 编译 
编译是语法的正确，函数和变量的声明正确。对于声明，只需要告诉编译器头文件的位置，
只要所有的语法正确就可以编译出中间目标文件，一般每一个c/c++文件都对应一个中间目标文件。
## 链接
链接主要是链接全局变量和函数。我们可以使用中间目标文件链接目标文件。链接器不管
源文件，只管中间目标函数。一般情况由于中间目标文件太多，我们把中间目标函数打包，
在window中是库文件Libary File(.lib文件).

总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。
在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，
编译器会给出一个警告，但可以生成Object File。而在链接程序时，
链接器会在所有的Object File中找寻函数的实现，如果找不到，
那到就会报链接错误码（Linker Error），
# Makefile介绍
make命令执行的时候需要指定一个makefile文件,告诉make怎样去编译和执行。
make的规则是
1. 如果这个工程么没有被编译过，所有的源文件都要被编译和链接。
2. 如果有几个c源文件被修改过，那么只编译被修改的源文件，并链接目标程序
3. 如果有几个头文件被修改过，我们需要编译引用这几个头文件的c文件，并链接目标程序
这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编
译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不
到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不
成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，
冒号后面的文件还是不在，那么对不起，我就不工作啦。

## make是如何工作的
1. 读入主Makefile (主Makefile中可以引用其他Makefile)
2. 读入被include的其他Makefile
3. 初始化文件中的变量
4. 推导隐晦规则, 并分析所有规则
5. 为所有的目标文件创建依赖关系链
6. 根据依赖关系, 决定哪些目标要重新生成,生成规则本节开头所示
7. 执行生成命令
1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，
make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依
赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。

通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，
那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，
以此来清除所有的目标文件，以便重编译。
## makefile主要的东西
1. 显示规则：如何生成一个或多个目标文件，这是书写者指出，
2. 隐式规则：make自动推导的功能。
3. 变量的定义：变量一般都是字符串，类似c语言的宏，makefile被执行的的时候会被
扩展到引用位置
4. 文件指示:包括三个部分，一是在一个makefile中引用另一个makefile,类似c语言
的include；二是根据某些特定的情况指定makefile中有效的部分，
像c语言的预编译器#if，还有一个是定义多行命令
5. 注释：注释用“#”表示
# makefile显式规则
## makefile的规则
```
          target... : prerequisites ...
          command
```
target也就是一个目标文件，可以是Object File，也可以是执行文件。
还可以是一个标签（Label），对于标签这种特性，
在后续的“伪目标”章节中会有叙述.

prerequisites就是，要生成那个target所需要的文件或是目标。

command也就是make需要执行的命令。（任意的Shell命令）。

这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于
prerequisites中的文件，其生成规则定义在command中。说白一点就是说，
prerequisites中如果有一个以上的文件比target文件要新的话，
command所定义的命令就会被执行。这就是Makefile的规则。
也就是Makefile中最核心的内容。

在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，
一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，
他只管执行所定义的命令。make会比较targets文件和prerequisites文件
的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，
或者target不存在的话，那么，make就会执行后续定义的命令。

## makefile多目标
Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，
并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，
这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），
这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。
   bigoutput littleoutput : text.g
           generate text.g -$(subst output,,$@) > $@
   上述规则等价于：
 
   bigoutput : text.g
           generate text.g -big > bigoutput
   littleoutput : text.g
           generate text.g -little > littleoutput
其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，
后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，
就像一个数组，“$@”依次取出目标，并执于命令。
## makefile静态模式多目标
静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：
```
<targets...>: <target-pattern>: <prereq-patterns ...>
　　　<commands>
```
targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。
target-parrtern是指明了targets的模式，也就是的目标集模式。
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。
这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。
如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，
而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行
二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），
并为其加上[.c]这个结尾，形成的新集合。
所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”
那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。
看一个例子：
```
   objects = foo.o bar.o
 
   all: $(objects)
 
   $(objects): %.o: %.c
           $(CC) -c $(CFLAGS) $< -o $@
``` 
上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$<”和“$@”则是自动化变量，“$<”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：
```
   foo.o : foo.c
           $(CC) -c $(CFLAGS) foo.c -o foo.o
   bar.o : bar.c
           $(CC) -c $(CFLAGS) bar.c -o bar.o
```

## 伪目标
伪目标并不是一个"目标(target)", 不像真正的目标那样会生成一个目标文件。
典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标。 
清空目标文件的规则

 每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，
 也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：
 ```
       clean:
           rm edit $(objects)
```
更为稳健的做法是：
```
       .PHONY : clean //.PHONY意思表示clean是一个“伪目标”
       clean :
               -rm edit $(objects)
```

而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，
继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成
make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放
在文件的最后”。
# 隐式规则 
如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，
make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，
那么这个行为就是隐含规则的自动推导
如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。
还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，
所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管
当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。
当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“
后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统
定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, 
.c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .
h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。
## c/c++ 用到的隐式规则的顺序
1. 编译C程序的隐含规则。
“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是
```
$(CC) –c $(CPPFLAGS) $(CFLAGS)
```
2. 编译C++程序的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.c”，并且其生成命令是
```
$(CXX) –c $(CPPFLAGS) $(CFLAGS)
```
（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）

...中间的暂时用不到就没有列出来

7. 汇编和汇编预处理的隐含规则。
“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”
，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。

8. 链接Object文件的隐含规则。
“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对
于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。
## 隐式规则中的变量

在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改
变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎
么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的
“-R”或“--no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。
我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数
相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量
### 关于命令的变量
AR      函数库打包程序。默认命令是“ar”。
AS      汇编语言编译程序。默认命令是“as”。
CC      C语言编译程序。默认命令是“cc”。
CXX     C++语言编译程序。默认命令是“g++”。
CPP     C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。
CTANGLE 转换C Web 到 C。默认命令是“ctangle”。
RM      删除文件命令。默认命令是“rm –f”。
### 关于命令参数的变量
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是
空。

ARFLAGS     函数库打包程序AR命令的参数。默认值是“rv”。
ASFLAGS     汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。
CFLAGS      C语言编译器参数。
CXXFLAGS    C++语言编译器参数。
CPPFLAGS    C预处理器参数。（ C 和 Fortran 编译器也会用到）。


# make 中使用变量
在makefile中我们可以使用变量。makefile的变量也就是一个字符串，
理解成C语言中的宏可能会更好。
比如，我们声明一个变量，叫objects，我们在makefile一开始就这样定义：
 ```   
    objects = main.o kbd.o command.o display.o \
             insert.o search.o files.o utils.o
```
于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这
个变量了。

# Makefile 综述

## makefile的文件名
默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件。
“GNUmakefile”，这个文件是GNU的make识别的。
指定特定的Makefile，你可以使用make的“-f”和“--file”参数，如：
```
make -f Make.Linux
make --file Make.AIX
```
## 引用其他makefile
在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会
原模原样的放在当前文件的包含位置。include的语法是：
include<filename>
filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符在include前面可以有一些空字符，
但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。
举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，
其包含了e.mk和f.mk，那么，下面的语句：
   include foo.make *.mk $(bar)
等价于：
   include foo.make a.mk b.mk c.mk e.mk f.mk
make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：
1. 如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。
2. 如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。
如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
-include<filename>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。
# 特殊符号
1. 反斜杠（\）是换行符的意思。

*     :: 表示任意一个或多个字符
?     :: 表示任意一个字符
[...] :: ex. [abcd] 表示a,b,c,d中任意一个字符, [^abcd]表示除a,b,c,d以外的字符, [0-9]表示 0~9中任意一个数字
~     :: 表示用户的home目录